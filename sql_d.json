{
  "exam_info": {
    "title": "数据库选择题集",
    "total_questions": 111,
    "types": ["单选题"]
  },
  "questions": [
    {
      "id": 1,
      "type": "单选题",
      "title": "以下关于数据库系统中‘数据’的描述，正确的是（ ）。",
      "options": {
        "A": "数据只能是数字形式",
        "B": "数据是指存储在计算机中的物理符号集合,包括数字、文字、图形等",
        "C": "数据不具有语义信息",
        "D": "数据与信息是完全相同的概念"
      },
      "correct_answer": "B",
      "analysis": "数据是数据库中存储的基本对象，可以是数字、文字、图形、图像、声音、语言等多种形式，这些数据经过数字化后存入计算机。数据是描述事物的符号记录，具有一定的语义信息。"
    },
    {
      "id": 2,
      "type": "单选题",
      "title": "以下关于数据库系统和文件系统的比较，正确的是（ ）。",
      "options": {
        "A": "文件系统和数据库系统都能实现数据共享，但数据库系统的共享性更高",
        "B": "文件系统和数据库系统的数据独立性相同",
        "C": "文件系统的数据冗余度比数据库系统更低",
        "D": "文件系统比数据库系统更能保证数据的一致性"
      },
      "correct_answer": "A",
      "analysis": "数据库系统相比文件系统的主要优势包括：更高的数据共享性、更低的冗余度、更高的数据独立性、更强的数据一致性保障。数据库系统允许多个用户同时访问数据，共享性更高。"
    },
    {
      "id": 3,
      "type": "单选题",
      "title": "下列四项中，不属于数据库系统的主要特点的是（）。",
      "options": {
        "A": "数据结构化",
        "B": "数据冗余度小",
        "C": "数据独立性高",
        "D": "程序标准化"
      },
      "correct_answer": "D",
      "analysis": "数据库系统的主要特点包括：数据结构化、数据冗余度小、数据独立性高、数据由DBMS统一管理和控制等。程序标准化不是数据库系统的特点，而是软件开发的要求。"
    },
    {
      "id": 4,
      "type": "单选题",
      "title": "下列关于数据库系统特点的描述，错误的是（ ）。",
      "options": {
        "A": "数据共享性高",
        "B": "数据冗余度高",
        "C": "数据独立性强",
        "D": "数据由DBMS统一管理"
      },
      "correct_answer": "B",
      "analysis": "数据库系统的重要特点是数据冗余度低，而不是高。数据库通过数据共享和统一管理，大大减少了数据冗余，避免了数据不一致问题。"
    },
    {
      "id": 5,
      "type": "单选题",
      "title": "下列不是数据库管理系统功能的是（）。",
      "options": {
        "A": "完整性控制",
        "B": "并发控制",
        "C": "通讯控制",
        "D": "处理机控制"
      },
      "correct_answer": "C",
      "analysis": "数据库管理系统（DBMS）的主要功能包括数据定义、数据操纵、数据库运行管理（完整性控制、安全性控制、并发控制）、数据库的建立和维护等。通讯控制和处理机控制通常由操作系统负责，不是DBMS的功能。"
    },
    {
      "id": 6,
      "type": "单选题",
      "title": "数据库DB,数据库系统DBS,数据库管理系统DBMS这三者之间的关系是 ( )。",
      "options": {
        "A": "DBS包括DB和DBMS",
        "B": "DBMS包括DB和DBS",
        "C": "DB包括DBS和DBMS",
        "D": "DBS就是DB,也就是DBMS"
      },
      "correct_answer": "A",
      "analysis": "数据库系统（DBS）是一个完整的系统，包括数据库（DB）、数据库管理系统（DBMS）、应用系统、数据库管理员（DBA）和用户等组成部分。DBMS是DBS的核心软件。"
    },
    {
      "id": 7,
      "type": "单选题",
      "title": "数据库系统的核心是 ( )。",
      "options": {
        "A": "数据库",
        "B": "软件工具",
        "C": "数据模型",
        "D": "数据库管理系统"
      },
      "correct_answer": "D",
      "analysis": "数据库管理系统（DBMS）是数据库系统的核心，负责数据库的建立、使用和维护，是用户与数据库之间的接口。"
    },
    {
      "id": 8,
      "type": "单选题",
      "title": "在数据库的三级模式结构中，描述全体数据的全局逻辑结构和特征的是（ ）。",
      "options": {
        "A": "外模式",
        "B": "内模式",
        "C": "存储模式",
        "D": "模式"
      },
      "correct_answer": "D",
      "analysis": "数据库的三级模式结构包括：外模式（用户视图）、模式（全局逻辑结构）、内模式（物理存储结构）。模式也称逻辑模式，描述全体数据的全局逻辑结构和特征。"
    },
    {
      "id": 9,
      "type": "单选题",
      "title": "在关系数据库系统中，关系类型改变时，用户程序不变。体现了（）。",
      "options": {
        "A": "数据的物理独立性",
        "B": "数据的逻辑独立性",
        "C": "数据的位置独立性",
        "D": "数据的存储独立性"
      },
      "correct_answer": "B",
      "analysis": "数据的逻辑独立性是指当数据库的模式（全局逻辑结构）发生改变时，通过调整外模式/模式映像，使外模式保持不变，从而应用程序无需修改。"
    },
    {
      "id": 10,
      "type": "单选题",
      "title": "当数据库的逻辑结构发生改变时，通过调整外模式/模式映像使外模式保持不变，从而应用程序无需修改，这体现了数据库的（ ）。",
      "options": {
        "A": "物理独立性",
        "B": "逻辑独立性",
        "C": "存储独立性",
        "D": "操作独立性"
      },
      "correct_answer": "B",
      "analysis": "逻辑独立性是通过外模式/模式映像实现的。当模式（逻辑结构）改变时，数据库管理员可以修改外模式/模式映像，使外模式保持不变，从而应用程序不需要修改，保证了数据的逻辑独立性。"
    },
    {
      "id": 11,
      "type": "单选题",
      "title": "当数据库的物理存储结构发生改变时，通过调整模式/内模式映像使模式保持不变，应用程序无需修改，这体现了数据库的（ ）。",
      "options": {
        "A": "逻辑独立性",
        "B": "物理独立性",
        "C": "操作独立性",
        "D": "存储独立性"
      },
      "correct_answer": "B",
      "analysis": "物理独立性是通过模式/内模式映像实现的。当数据库的物理存储结构（内模式）发生改变时，数据库管理员可以修改模式/内模式映像，使模式保持不变，从而应用程序不需要修改，保证了数据的物理独立性。"
    },
    {
      "id": 12,
      "type": "单选题",
      "title": "设有关系R和S，关系代数R-(R-S)表示的是（ ）。",
      "options": {
        "A": "R∩S",
        "B": "R-S",
        "C": "R÷S",
        "D": "RUS"
      },
      "correct_answer": "A",
      "analysis": "R-S表示R中有但S中没有的元组，R-(R-S)就是从R中去掉那些不在S中的元组，剩下的就是R和S共有的元组，即R∩S。"
    },
    {
      "id": 13,
      "type": "单选题",
      "title": "下列关于外键约束的描述，正确的是（ ）。",
      "options": {
        "A": "外键必须与主键同名",
        "B": "外键值必须唯一",
        "C": "外键可以引用非主键字段",
        "D": "外键字段必须与主键字段类型一致"
      },
      "correct_answer": "D",
      "analysis": "外键约束要求外键字段必须与引用的主键字段类型一致，但不必同名。外键值不必唯一（可以重复），可以引用其他表的主键或唯一键，但通常引用主键。"
    },
    {
      "id": 14,
      "type": "单选题",
      "title": "在关系模型中，元组的集合称为（ ）。",
      "options": {
        "A": "元组集",
        "B": "关系",
        "C": "域",
        "D": "分量"
      },
      "correct_answer": "B",
      "analysis": "在关系模型中，关系是元组的集合，每个元组是关系中的一个记录。关系对应二维表，元组对应行，属性对应列。"
    },
    {
      "id": 15,
      "type": "单选题",
      "title": "关系代数中，从两个关系中找出相同元组的运算是（ ）。",
      "options": {
        "A": "并",
        "B": "交",
        "C": "差",
        "D": "笛卡尔积"
      },
      "correct_answer": "B",
      "analysis": "交运算（∩）的结果是两个关系中所有相同的元组组成的集合。并运算（∪）是合并两个关系中的元组，差运算（-）是第一个关系中有而第二个关系中没有的元组。"
    },
    {
      "id": 16,
      "type": "单选题",
      "title": "从关系中筛选出满足给定条件的元组，并保留原关系结构的关系代数运算称为（ ）。",
      "options": {
        "A": "筛选运算",
        "B": "选择运算",
        "C": "投影运算",
        "D": "笛卡尔积运算"
      },
      "correct_answer": "B",
      "analysis": "选择运算（σ）是从关系中选取满足条件的元组，结果保持原关系结构（相同的属性列）。投影运算（Π）是选择属性列，改变关系结构。"
    },
    {
      "id": 17,
      "type": "单选题",
      "title": "关系代数表达式σ_条件 (R)表示的是（ ）。",
      "options": {
        "A": "投影运算",
        "B": "选择运算",
        "C": "连接运算",
        "D": "除法运算"
      },
      "correct_answer": "B",
      "analysis": "σ表示选择运算，从关系R中选择满足条件的元组。投影运算用Π表示，连接运算用⨝表示，除法运算用÷表示。"
    },
    {
      "id": 18,
      "type": "单选题",
      "title": "下列关系运算中，属于专门的关系运算的是（ ）。",
      "options": {
        "A": "选择",
        "B": "并运算",
        "C": "交运算",
        "D": "笛卡尔积"
      },
      "correct_answer": "A",
      "analysis": "专门的关系运算包括选择、投影、连接、除等。并、交、差、笛卡尔积属于传统的集合运算。"
    },
    {
      "id": 19,
      "type": "单选题",
      "title": "已知关系：员工（工号，姓名，部门，工资），部门（部门号，部门名，经理）。表达“查询部门名为‘技术部’的员工姓名及工资”的关系代数表达式是（ ）。",
      "options": {
        "A": "Π姓名,工资(σ部门名='技术部'(员工×部门))",
        "B": "Π姓名,工资(σ部门名='技术部'(员工⨝部门))",
        "C": "σ姓名,工资(Π部门名='技术部'(员工⨝部门))",
        "D": "Π姓名,工资(Π部门名='技术部'(部门))"
      },
      "correct_answer": "B",
      "analysis": "正确的关系代数表达式是：先进行员工和部门的连接运算（通过部门号相等连接），然后选择部门名为'技术部'的元组，最后投影到姓名和工资属性上。选项B正确使用了连接运算和正确的操作顺序。"
    },
    {
      "id": 20,
      "type": "单选题",
      "title": "数据库中，用于建立两个表之间关联的完整性约束是（ ）。",
      "options": {
        "A": "主键约束",
        "B": "外键约束",
        "C": "非空约束",
        "D": "唯一约束"
      },
      "correct_answer": "B",
      "analysis": "外键约束用于建立两个表之间的关联，确保一个表的外键值引用另一个表的主键值，实现参照完整性。主键约束保证实体完整性，非空约束和唯一约束保证用户定义的完整性。"
    },
    {
"id": 21,
"type": "单选题",
"title": "表A有3行数据，表B有4行数据，表C有2行数据。这三个表进行交叉连接（Cross Join）后，结果集的行数是（ ）。",
"options": {
"A": "9行",
"B": "12行",
"C": "24行",
"D": "36行"
},
"correct_answer": "C",
"analysis": "交叉连接（笛卡尔积）的行数是各表行数的乘积。表A（3行）×表B（4行）×表C（2行）= 3×4×2 = 24行。"
},
{
"id": 22,
"type": "单选题",
"title": "设关系R、S、W各有6个元组，那么这三个关系的笛卡尔积的元组个数是( )。",
"options": {
"A": "6",
"B": "216",
"C": "18",
"D": "不确定"
},
"correct_answer": "B",
"analysis": "笛卡尔积的元组个数是各关系元组数的乘积。三个关系各有6个元组，笛卡尔积的元组个数为6×6×6=216。"
},
{
"id": 23,
"type": "单选题",
"title": "关于关系的特性，说法不正确的是（）。",
"options": {
"A": "关系的任意两列上的值不能完全相同",
"B": "关系的任意两个元组不能完全相同",
"C": "元组相同是指两个元组的每个分量都相同",
"D": "在同一个关系中如存在相同的元组，则仅保留其中的一个"
},
"correct_answer": "A",
"analysis": "关系的特性包括：元组不可重复（任意两个元组不能完全相同），但列的值可以重复（不同列的值可以相同）。选项A错误，因为关系的不同列可以有相同的值。"
},
{
"id": 24,
"type": "单选题",
"title": "关系代数中投影运算是对关系进行的（）。",
"options": {
"A": "垂直分割",
"B": "水平分割",
"C": "合并操作",
"D": "乘积操作"
},
"correct_answer": "A",
"analysis": "投影运算（Π）是从关系中选择若干属性列，是对关系的垂直分割（选择列）。选择运算（σ）是对关系的水平分割（选择行）。"
},
{
"id": 25,
"type": "单选题",
"title": "在关系代数运算中，传统的集合运算为( )。",
"options": {
"A": "并、差、选择、投影",
"B": "并、差、自然连接、笛卡儿积",
"C": "并、差、交、笛卡儿积",
"D": "并、差、交、选择"
},
"correct_answer": "C",
"analysis": "关系代数运算分为两类：传统的集合运算（并、差、交、笛卡尔积）和专门的关系运算（选择、投影、连接、除）。"
},
{
"id": 26,
"type": "单选题",
"title": "关于关系模型，下列叙述不正确的是( )。",
"options": {
"A": "一个关系只能有一个主码",
"B": "列的次序可以任意交换",
"C": "行的次序可以任意交换",
"D": "一个列的值可以来自不同的域"
},
"correct_answer": "D",
"analysis": "关系模型要求每个属性（列）的值必须来自同一个域，即同一列的值必须是相同的数据类型和取值范围。选项D错误，其他选项都是关系模型的基本特性。"
},
{
"id": 27,
"type": "单选题",
"title": "若关系R中有属性A→B，B→C，则A→C属于（ ）。",
"options": {
"A": "部分依赖",
"B": "传递依赖",
"C": "多值依赖",
"D": "函数依赖"
},
"correct_answer": "B",
"analysis": "传递依赖是指如果A→B，B→C，且B不决定A，C不包含于B，则A→C是传递依赖。这是规范化理论中需要消除的依赖类型。"
},
{
"id": 28,
"type": "单选题",
"title": "关系R(A,B,C)中A→B, B→C的依赖类型是( )。",
"options": {
"A": "完全函数依赖",
"B": "部分函数依赖",
"C": "传递函数依赖",
"D": "多值依赖"
},
"correct_answer": "C",
"analysis": "传递函数依赖是指如果A→B，B→C，且B不决定A，C不包含于B，则A→C是传递函数依赖。这是第三范式（3NF）需要消除的依赖类型。"
},
{
"id": 29,
"type": "单选题",
"title": "关系模式R(A,B,C,D)中，若存在A→B和B→C，则（ ）。",
"options": {
"A": "A→C一定成立",
"B": "A→C不一定成立",
"C": "R一定属于BCNF",
"D": "R一定属于3NF"
},
"correct_answer": "A",
"analysis": "根据函数依赖的传递律，如果A→B且B→C，则A→C一定成立（前提是B不决定A，C不包含于B）。但仅凭这两个依赖，无法确定R属于BCNF或3NF，还需要考虑其他依赖和候选键。"
},
{
"id": 30,
"type": "单选题",
"title": "若关系模式R(A,B,C,D)的函数依赖集F={AB→C, C→D, D→B}，则R中存在（ ）。",
"options": {
"A": "部分函数依赖",
"B": "传递函数依赖",
"C": "多值依赖",
"D": "连接依赖"
},
"correct_answer": "B",
"analysis": "由函数依赖集可知，AB→C，C→D，D→B，存在传递依赖：AB→C，C→D，所以AB→D是传递依赖（C不决定AB，D不包含于C）；同时C→D，D→B，所以C→B也是传递依赖（D不决定C，B不包含于D）。"
},
	{
"id": 31,
"type": "单选题",
"title": "关系模式R(A1,A2,A3,A4,A5)，已知函数依赖集F={A1→A3,A2→A4,A4→A5}，则R的候选码是（ ）。",
"options": {
"A": "(A1,A2)",
"B": "(A1,A3)",
"C": "(A1,A4)",
"D": "(A1,A5)"
},
"correct_answer": "A",
"analysis": "候选码是指能唯一标识元组的最小属性集。根据函数依赖集，A1可以决定A3，A2可以决定A4，A4可以决定A5。但A1不能决定A2、A4、A5；A2不能决定A1、A3。因此，单独A1或A2都不能决定所有属性。组合(A1,A2)可以决定A1、A2，通过A1→A3得到A3，通过A2→A4得到A4，再通过A4→A5得到A5，所以(A1,A2)能决定所有属性，且是最小的（去掉任何一个属性都不能决定所有属性），因此候选码是(A1,A2)。"
},
{
"id": 32,
"type": "单选题",
"title": "若关系模式 R∈2NF，且消除了非主属性对码的传递依赖，则R属于（ ）。",
"options": {
"A": "1NF",
"B": "2NF",
"C": "3NF",
"D": "BCNF"
},
"correct_answer": "C",
"analysis": "第三范式（3NF）要求在满足第二范式（2NF）的基础上，消除非主属性对码的传递依赖。因此，题目描述的条件正是第三范式的定义。"
},
{
"id": 33,
"type": "单选题",
"title": "关系模式R（A,B,C,D,E），函数依赖集 F={A→B,A→C,D→E}，则R的候选码是（ ）。",
"options": {
"A": "(A,D)",
"B": "(A,B)",
"C": "(A,C)",
"D": "(D,E)"
},
"correct_answer": "A",
"analysis": "根据函数依赖集，A可以决定B和C，但不能决定D和E；D可以决定E，但不能决定A、B、C。因此，单独A或D都不能决定所有属性。组合(A,D)可以决定A、D，通过A→B、A→C得到B和C，通过D→E得到E，所以(A,D)能决定所有属性，且是最小的，因此候选码是(A,D)。"
},
{
"id": 34,
"type": "单选题",
"title": "关系模式 R(A, B, C, D, E)，已知函数依赖集 F = {A→D, B→C, B→E}，则 R 的最高范式是（ ）。",
"options": {
"A": "1NF",
"B": "2NF",
"C": "3NF",
"D": "BCNF"
},
"correct_answer": "A",
"analysis": "首先确定候选码。根据函数依赖集，没有属性可以决定A和B，且A和B不能相互决定，也不能决定其他所有属性。实际上，候选码可能是(A,B)（因为A和B不能由其他属性决定，且(A,B)可以决定所有属性？但依赖集中没有直接给出(A,B)决定其他属性的依赖，所以需要通过属性闭包来判断）。计算(A,B)的闭包：包含A、B，由A→D得到D，由B→C和B→E得到C和E，所以(A,B)可以决定所有属性，因此候选码是(A,B)。非主属性C、D、E都完全依赖于候选码（因为A和B都是候选码的一部分，不能单独决定它们），所以满足2NF。但是存在传递依赖吗？例如A→D，而D是非主属性，且D不能决定候选码，所以存在非主属性D对候选码的传递依赖？实际上，A是候选码的一部分，A→D是直接依赖，不是传递依赖。对于B→C和B→E也是直接依赖。但这里没有非主属性对候选码的传递依赖，所以满足3NF？然而，检查BCNF：对于每一个函数依赖，决定因子都包含码吗？A→D中，A不是超码（因为A不能决定所有属性），所以不满足BCNF。但题目问最高范式，从函数依赖看，候选码为(A,B)，所有非主属性都完全依赖于候选码，且没有传递依赖（因为所有依赖的左部都是候选码的一部分），所以应该满足3NF。但仔细分析：存在部分依赖吗？没有，因为非主属性完全依赖于整个候选码。存在传递依赖吗？例如，如果存在A→B,B→C，那么A→C是传递，但这里没有这样的依赖。所以满足3NF。但为什么答案给1NF？可能因为题目中没有说明所有属性都是原子的（即可能不满足1NF的原子性），但通常我们假设关系模式至少满足1NF。从函数依赖角度，我们判断范式级别。然而，根据函数依赖，候选码为(A,B)，非主属性C、D、E完全依赖于候选码，且不存在传递依赖（因为依赖的左部都是候选码的一部分，所以是直接依赖），所以满足3NF。但注意：A→D中，A是码的一部分，但A不是码，所以这个依赖违反了BCNF，但不违反3NF。因此最高范式是3NF。但选项中有BCNF，而这里不满足BCNF，所以最高是3NF。但答案给的是1NF，可能有误。按照分析，应该是3NF。但根据常见的题目，如果候选码是(A,B)，那么A→D中，A不是超码，所以不满足BCNF，但满足3NF。因此，如果题目说最高范式是1NF，那可能意味着我们假设关系模式不满足2NF或3NF的条件。但根据函数依赖集，我们可以判断它至少满足2NF，因为非主属性完全依赖于候选码。所以我认为正确答案应该是3NF。但题目提供的选项是1NF、2NF、3NF、BCNF，根据分析，最高是3NF。然而，我们再看一下：函数依赖集中，B→C和B→E，B是候选码的一部分，但不是超码，所以这些依赖也违反了BCNF，但不违反3NF。因此，最高范式是3NF。但原题答案给的是1NF，可能因为题目没有说明属性都是原子的，或者有其他隐含条件。根据标准分析，应该选3NF。但这里按照题目给出的选项，我们只能选择其中一个。根据常见题目，这种依赖集通常最高到3NF。所以选C。但为了准确，我们保留分析。"
},
{
"id": 35,
"type": "单选题",
"title": "关系模式R（A,B,C,D），函数依赖集 F={A→B,B→C,C→D}，则R的最高范式是（ ）。",
"options": {
"A": "1NF",
"B": "2NF",
"C": "3NF",
"D": "BCNF"
},
"correct_answer": "B",
"analysis": "候选码是A（因为A可以决定B，B决定C，C决定D，所以A可以决定所有属性）。非主属性B、C、D都完全依赖于候选码A（因为只有一个属性，所以是完全依赖），满足2NF。但存在传递依赖：A→B, B→C, 所以A→C是传递依赖；同样A→C, C→D, 所以A→D也是传递依赖。因此，存在非主属性对码的传递依赖，不满足3NF。所以最高范式是2NF？但注意，3NF要求消除非主属性对码的传递依赖，这里存在传递依赖，所以不满足3NF，因此最高是2NF。但选项C是3NF，D是BCNF。实际上，根据函数依赖，候选码是A，非主属性B、C、D都完全依赖于A，但存在传递依赖，所以最高是2NF。因此正确答案应该是B。但题目问最高范式，从依赖看，不满足3NF，所以选B。"
},
{
"id": 36,
"type": "单选题",
"title": "若关系模式R(A,B,C,D,E,F)，F={E→D,C→B,CE→F,B→A}，则R的最高范式是（ ）。",
"options": {
"A": "1NF",
"B": "2NF",
"C": "3NF",
"D": "4NF"
},
"correct_answer": "A",
"analysis": "首先确定候选码。通过计算属性闭包，发现CE的闭包包含C、E，由E→D得到D，由C→B得到B，由CE→F得到F，由B→A得到A，所以CE可以决定所有属性，因此候选码是CE。非主属性A、B、D、F。检查是否满足2NF：非主属性是否完全依赖于候选码？对于B，有C→B，而C是候选码的一部分，所以B部分依赖于候选码（因为只需要C就能决定B，不需要E），因此不满足2NF。所以最高范式是1NF。因此选A。"
},
{
"id": 37,
"type": "单选题",
"title": "假设关系 R<U，F>，U={A,B,C,D},F={A→BC,AC→D,B→D}，那么在关系R中 （）。",
"options": {
"A": "不存在传递依赖，候选关键字A",
"B": "不存在传递依赖，候选关键字AC",
"C": "存在传递依赖 A→D，候选关键字A",
"D": "存在传递依赖B→D，候选关键字C"
},
"correct_answer": "C",
"analysis": "首先确定候选码。计算A的闭包：A可以决定B和C（A→BC），然后通过AC→D，但注意AC→D，而A已经可以决定C，所以A可以决定AC，从而可以决定D，所以A的闭包包含ABCD，因此A是候选码。另外，AC也是超码，但不是最小的，因为A已经是候选码。所以候选关键字是A。检查传递依赖：由A→BC和B→D，且B不决定A（因为B只能决定D），所以存在传递依赖A→D。因此，存在传递依赖A→D，候选关键字是A。选项C正确。"
},
{
"id": 38,
"type": "单选题",
"title": "在数据库中，用于限制某一列的取值范围的完整性约束是（ ）。",
"options": {
"A": "主键约束",
"B": "唯一性约束",
"C": "非空约束",
"D": "检查约束"
},
"correct_answer": "D",
"analysis": "检查约束（CHECK）用于限制某一列的取值范围，确保输入的值满足指定的条件。主键约束保证唯一性和非空，唯一性约束保证唯一但允许空值，非空约束保证列不能为空。"
},
{
"id": 39,
"type": "单选题",
"title": "在数据库设计中，数据字典是在哪个阶段建立的？（ ）。",
"options": {
"A": "需求分析阶段",
"B": "概念设计阶段",
"C": "逻辑设计阶段",
"D": "物理设计阶段"
},
"correct_answer": "A",
"analysis": "数据字典是在需求分析阶段建立的，用于收集和整理用户需求，定义数据项、数据结构、数据流、数据存储等。它是数据库设计的基础。"
},
{
"id": 40,
"type": "单选题",
"title": "以下哪项是物理结构设计阶段对逻辑模型的合理调整（ ）。",
"options": {
"A": "增加关系模式的属性",
"B": "将一个大表拆分为多个小表",
"C": "修改实体间的联系类型",
"D": "删除逻辑模型中的某个关系"
},
"correct_answer": "B",
"analysis": "物理结构设计阶段主要考虑如何将逻辑模型有效地存储到物理设备上，包括存储结构、存取方法、索引设计等。将一个大表拆分为多个小表（如垂直分割或水平分割）是物理设计阶段常用的优化手段，以提高性能。而增加属性、修改联系类型、删除关系等属于逻辑设计阶段的调整。"
},

{
      "id": 41,
      "type": "单选题",
      "title": "数据库设计中，“为避免数据冗余和更新异常，将一个关系模式分解为多个关系模式”的过程称为（ ）。",
      "options": {
        "A": "模式合并",
        "B": "规范化",
        "C": "逆规范化",
        "D": "概念建模"
      },
      "correct_answer": "B",
      "analysis": "规范化是指通过分解关系模式来消除数据冗余、插入异常、更新异常和删除异常等问题，提升数据库设计的合理性。"
    },
    {
      "id": 42,
      "type": "单选题",
      "title": "数据库设计中，将 E-R 模型转换为关系模式的阶段是（ ）。",
      "options": {
        "A": "需求分析",
        "B": "概念结构设计",
        "C": "逻辑结构设计",
        "D": "物理结构设计"
      },
      "correct_answer": "C",
      "analysis": "逻辑结构设计阶段的核心工作是将概念结构（E-R模型）转换为具体数据库管理系统支持的关系模式。"
    },
    {
      "id": 43,
      "type": "单选题",
      "title": "数据库设计中，若关系模式存在数据冗余、更新异常等问题，通过将其分解为满足更高范式要求的多个关系模式，这一优化过程的核心目标是（ ）。",
      "options": {
        "A": "提升数据查询速度",
        "B": "实现关系模式规范化",
        "C": "简化数据库物理存储",
        "D": "降低数据类型复杂度"
      },
      "correct_answer": "B",
      "analysis": "规范化的核心目标是消除数据冗余和更新异常，通过分解关系模式满足1NF、2NF、3NF等范式要求。"
    },
    {
      "id": 44,
      "type": "单选题",
      "title": "在数据库设计过程中，绘制数据流图（DFD）的阶段是（ ）。",
      "options": {
        "A": "需求分析",
        "B": "概念结构设计",
        "C": "逻辑结构设计",
        "D": "物理结构设计"
      },
      "correct_answer": "A",
      "analysis": "需求分析阶段需要通过数据流图（DFD）和数据字典来描述系统的数据流和数据需求。"
    },
    {
      "id": 45,
      "type": "单选题",
      "title": "在数据库设计中，E-R图产生于（ ）。",
      "options": {
        "A": "需求分析阶段",
        "B": "需求分析阶段",
        "C": "逻辑设计阶段",
        "D": "概念设计阶段"
      },
      "correct_answer": "D",
      "analysis": "概念结构设计阶段的核心成果是E-R图（实体-联系图），用于描述现实世界的实体和联系。注意：题目选项中有两个“需求分析阶段”，可能为笔误，但根据知识，E-R图产生于概念设计阶段。"
    },
    {
      "id": 46,
      "type": "单选题",
      "title": "在E-R模型中，用于描述实体之间联系的术语是（ ）。",
      "options": {
        "A": "属性",
        "B": "域",
        "C": "关系",
        "D": "键"
      },
      "correct_answer": "C",
      "analysis": "E-R模型中，实体之间的关联关系称为“联系”，在关系模型中对应为“关系”。"
    },
    {
      "id": 47,
      "type": "单选题",
      "title": "从E-R模型关系向关系模型转换时，一个M:N联系转换为关系模式时，该关系模式的码是（ ）。",
      "options": {
        "A": "M端实体的码",
        "B": "N端实体的码",
        "C": "M端实体码与N端实体码组合",
        "D": "重新选取其他属性"
      },
      "correct_answer": "C",
      "analysis": "M:N联系转换为关系模式时，需要将两端实体的主键组合作为该关系模式的联合主键。"
    },
    {
      "id": 48,
      "type": "单选题",
      "title": "数据库应用系统设计的需求分析阶段生成的文档是数据字典和（）。",
      "options": {
        "A": "数据流图",
        "B": "E-R图",
        "C": "功能模块图",
        "D": "UML图"
      },
      "correct_answer": "A",
      "analysis": "需求分析阶段的核心交付物是数据字典和数据流图（DFD），E-R图属于概念设计阶段产物。"
    },
    {
      "id": 49,
      "type": "单选题",
      "title": "概念模型是现实世界的第一层抽象，这一类最著名的模型是( )。",
      "options": {
        "A": "层次模型",
        "B": "关系模型",
        "C": "实体-联系模型",
        "D": "网状模型"
      },
      "correct_answer": "C",
      "analysis": "实体-联系（E-R）模型是最经典的概念模型，用于抽象描述现实世界的实体和联系。"
    },
    {
      "id": 50,
      "type": "单选题",
      "title": "在E-R图中，联系的类型不包括( )。",
      "options": {
        "A": "一对一（1:1）",
        "B": "一对多（1:N）",
        "C": "多对多（M:N）",
        "D": "多对一（N:1）"
      },
      "correct_answer": "D",
      "analysis": "E-R图中联系的基本类型为1:1、1:N、M:N，多对一（N:1）属于一对多的反向表述，并非独立类型。"
    },
 {
      "id": 51,
      "type": "单选题",
      "title": "代码Delete from customer WHERE c_id=1 and cname=\"张倩\"执行的操作是（ ）。",
      "options": {
        "A": "删除姓名叫张倩且c_id为1的记录",
        "B": "删除姓名叫张倩的记录",
        "C": "删除c_id值为1的记录",
        "D": "更新c_id值为1的姓名为张倩"
      },
      "correct_answer": "A",
      "analysis": "DELETE语句的WHERE子句用于指定删除条件，多个条件用AND连接时表示同时满足。"
    },
    {
      "id": 52,
      "type": "单选题",
      "title": "代码UPDATE student SET age=age+1 WHERE sdept='计算机学院'执行的操作是（ ）。",
      "options": {
        "A": "将计算机学院所有学生的年龄增加1岁",
        "B": "将计算机学院学生的年龄设置为1岁",
        "C": "查询计算机学院所有学生的年龄",
        "D": "删除计算机学院年龄为1岁的学生记录"
      },
      "correct_answer": "A",
      "analysis": "UPDATE语句的SET子句中age=age+1表示将原有年龄值加1，WHERE子句限定仅修改计算机学院的学生。"
    },
    {
      "id": 53,
      "type": "单选题",
      "title": "下列关于嵌套查询的说法中，哪一项是正确的（ ）。",
      "options": {
        "A": "嵌套查询不能引用外部查询的列",
        "B": "嵌套查询可以嵌套在SELECT、FROM和WHERE子句中",
        "C": "嵌套查询只能返回单个值",
        "D": "嵌套查询的执行顺序总是先执行主查询再执行子查询"
      },
      "correct_answer": "B",
      "analysis": "嵌套查询（子查询）可以出现在SELECT、FROM、WHERE、HAVING等多个子句中，支持多值返回，执行顺序通常为先子查询后主查询（相关子查询除外）。"
    },
    {
      "id": 54,
      "type": "单选题",
      "title": "在SQL中，以下哪条语句可以正确地按部门分组并计算每个部门的平均工资（ ）。",
      "options": {
        "A": "SELECT department, AVG(salary) FROM employees;",
        "B": "SELECT department, AVG(salary) FROM employees GROUP BY department;",
        "C": "SELECT AVG(salary) FROM employees;",
        "D": "SELECT department, SUM(salary) FROM employees;"
      },
      "correct_answer": "B",
      "analysis": "使用聚合函数（如AVG）时，非聚合列必须出现在GROUP BY子句中，GROUP BY department表示按部门分组计算平均工资。"
    },
    {
      "id": 55,
      "type": "单选题",
      "title": "设有一个关系：DEPT(DNO,DNAME)，如果要找出倒数第三个字母为W，并且至少包含4个字母的DNAME，则查询条件子句应写成 WHERE DNAME LIKE（ ）。",
      "options": {
        "A": "'__W_% '",
        "B": "'_%W__ '",
        "C": "'_W__'",
        "D": "'_W__% '"
      },
      "correct_answer": "B",
      "analysis": "LIKE通配符中，_匹配单个字符，%匹配任意字符。_%W__ 表示：任意字符+任意字符+W+两个字符，即倒数第三个字母为W且至少4个字符。"
    },
    {
      "id": 56,
      "type": "单选题",
      "title": "利用T-SQL语言创建表的语句是（）。",
      "options": {
        "A": "Delete Table",
        "B": "Drop Table",
        "C": "Add Table",
        "D": "Create Table"
      },
      "correct_answer": "D",
      "analysis": "T-SQL中创建表的核心语句是CREATE TABLE，Delete用于删除数据，Drop用于删除表结构，Add用于新增列。"
    },
    {
      "id": 57,
      "type": "单选题",
      "title": "在SQL中，与“IN”等价的操作是（ ）。",
      "options": {
        "A": "=ALL",
        "B": "=ANY",
        "C": "!=ALL",
        "D": "!=ANY"
      },
      "correct_answer": "B",
      "analysis": "IN表示匹配列表中的任意一个值，等价于=ANY；ALL表示匹配列表中的所有值，!=ALL等价于NOT IN。"
    },
    {
      "id": 58,
      "type": "单选题",
      "title": "在T-SQL中，与“NOT IN”等价的操作是（）。",
      "options": {
        "A": "= ALL",
        "B": "< >ALL",
        "C": "= SOME",
        "D": "< >SOME"
      },
      "correct_answer": "B",
      "analysis": "NOT IN表示不等于列表中的任何一个值，等价于<>ALL（<>是不等于的标准写法）；SOME与ANY含义相同。"
    },
    {
      "id": 59,
      "type": "单选题",
      "title": "有学生选课表sc，包含学生学号sno、课程编号cno，以下能够返回至少被3名学生选修过的课程编号cno的SQL语句是（ ）。",
      "options": {
        "A": "SELECT cno FROM sc WHERE COUNT (sno) > 2;",
        "B": "SELECT cno FROM sc GROUP BY cno HAVING COUNT (sno)>=3;",
        "C": "SELECT cno FROM sc HAVING COUNT (sno) > 2 GROUP BY cno;",
        "D": "SELECT cno FROM sc WHERE MAX (sno)>=3 GROUP BY cno;"
      },
      "correct_answer": "B",
      "analysis": "聚合函数（COUNT）不能用于WHERE子句，需用HAVING子句过滤分组结果；GROUP BY cno按课程分组，HAVING COUNT(sno)>=3筛选出选修人数≥3的课程。"
    },
    {
      "id": 60,
      "type": "单选题",
      "title": "SQL查询中，以下哪个语句用于去除结果集中的重复行（ ）。",
      "options": {
        "A": "DISTINCT",
        "B": "UNIQUE",
        "C": "DIFFERENT",
        "D": "REMOVE DUPLICATES"
      },
      "correct_answer": "A",
      "analysis": "DISTINCT是SQL标准中去除重复行的关键字，需放在SELECT之后；UNIQUE通常用于约束定义，而非查询去重。"
    },
{
      "id": 61,
      "type": "单选题",
      "title": "SQL语句中，向基本表增加字段的语句是( )。",
      "options": {
        "A": "Insert Into",
        "B": "Alter Table Add",
        "C": "Modify Column",
        "D": "Update Column"
      },
      "correct_answer": "B",
      "analysis": "修改表结构使用ALTER TABLE语句，新增列的语法为ALTER TABLE 表名 ADD 列名 数据类型；Insert Into用于插入数据，Update用于更新数据。"
    },
    {
      "id": 62,
      "type": "单选题",
      "title": "用于返回系统当前日期的函数是( )。",
      "options": {
        "A": "YEAR()",
        "B": "MAX()",
        "C": "now( )",
        "D": "curdate()"
      },
      "correct_answer": "D",
      "analysis": "now()返回当前日期和时间（如2026-01-14 10:00:00）；curdate()仅返回日期；YEAR()返回年份；MAX()是聚合函数。"
    },
    {
      "id": 63,
      "type": "单选题",
      "title": "如果需要查询关系R中属性A的值为NULL的元组，则选择子句应为 ( )。",
      "options": {
        "A": "Where A = NULL",
        "B": "Where A == NULL",
        "C": "Where A is NULL",
        "D": "Where A not is NULL"
      },
      "correct_answer": "C",
      "analysis": "NULL表示未知值，不能用=、==等比较运算符，必须用IS NULL（为空）或IS NOT NULL（不为空）。"
    },
    {
      "id": 64,
      "type": "单选题",
      "title": "对表中数据进行删除的操作是（ ）。",
      "options": {
        "A": "DELETE",
        "B": "ALTER",
        "C": "DROP",
        "D": "UPDATE"
      },
      "correct_answer": "A",
      "analysis": "DELETE用于删除表中的数据（可指定条件）；DROP用于删除表/数据库结构；ALTER用于修改表结构；UPDATE用于更新数据。"
    },
    {
      "id": 65,
      "type": "单选题",
      "title": "SQL语句中，用于删除表结构的命令是（ ）。",
      "options": {
        "A": "DELETE TABLE",
        "B": "DROP TABLE",
        "C": "REMOVE TABLE",
        "D": "CLEAR TABLE"
      },
      "correct_answer": "B",
      "analysis": "DROP TABLE是删除表结构的标准SQL命令，执行后表及所有数据都会被删除，且无法恢复（无备份时）。"
    },
    {
      "id": 66,
      "type": "单选题",
      "title": "已知关系sc(sno,cno,score)，下列SQL语句语法正确的是（ ）。",
      "options": {
        "A": "SELECT * FROM sc WHERE score > '60'",
        "B": "SELECT sno, AVG(score) FROM sc",
        "C": "SELECT cno, COUNT(*) FROM sc",
        "D": "SELECT * FROM sc ORDER BY score DESC"
      },
      "correct_answer": "D",
      "analysis": "A错误：score是数值类型，无需加单引号；B/C错误：聚合函数（AVG/COUNT）与非聚合列（sno/cno）同时查询时需加GROUP BY；D正确：ORDER BY score DESC表示按分数降序排列。"
    },
    {
      "id": 67,
      "type": "单选题",
      "title": "若要求查找‘李’姓学生的学生号和姓名，正确的 SQL语句是（ ）。",
      "options": {
        "A": "SELECT S#,SNAME FROM S WHERE SNAME=’李%’;",
        "B": "SELECT S#,SNAME FROM S WHERE SNAME=’%李%’;",
        "C": "SELECT S#,SNAME FROM S WHERE SNAME LIKE ’李%’;",
        "D": "SELECT S#,SNAME FROM S WHERE SNAME LIKE ’%李%’;"
      },
      "correct_answer": "C",
      "analysis": "模糊查询需用LIKE关键字，=不支持通配符；李%表示以“李”开头的姓名（李姓），%李%表示包含“李”的姓名。"
    },
    {
      "id": 68,
      "type": "单选题",
      "title": "用下面的T-SQL语句建立一个基本表：CREATE  TABLE  Student ( Sno CHAR(4) PRIMARY KEY , Sname CHAR(8) NOT NULL , Sex CHAR(2) , age INT )可以插入到表中的元组是（）。",
      "options": {
        "A": "'5021'，'刘祥'，男，21",
        "B": "NULL，'刘祥'，NULL，21",
        "C": "'5021'，NULL，男，21",
        "D": "'5021'，'刘祥'，NULL，NULL"
      },
      "correct_answer": "D",
      "analysis": "Sno是主键（非空且唯一），B错误；Sname设置NOT NULL，C错误；A中“男”需加单引号；D符合所有约束：Sno非空、Sname非空，Sex和age可为NULL。"
    },
    {
      "id": 69,
      "type": "单选题",
      "title": "下列哪个子句中不能使用嵌套查询（ ）。",
      "options": {
        "A": "SELECT",
        "B": "FROM",
        "C": "WHERE",
        "D": "ORDER BY"
      },
      "correct_answer": "D",
      "analysis": "ORDER BY子句用于排序，只能引用查询结果中的列名或列序号，不能使用嵌套查询；SELECT、FROM、WHERE均可使用子查询。"
    },
    {
      "id": 70,
      "type": "单选题",
      "title": "SQL中，用于合并两个查询结果的运算符是（ ）。",
      "options": {
        "A": "UNION",
        "B": "INTERSECT",
        "C": "MINUS",
        "D": "JOIN"
      },
      "correct_answer": "A",
      "analysis": "UNION用于合并两个查询结果集（自动去重）；INTERSECT是交集，MINUS是差集（MySQL不支持），JOIN是表连接（非结果集合并）。"
    },
 {
      "id": 71,
      "type": "单选题",
      "title": "视图是一个虚表，视图的构造基于（ ）。",
      "options": {
        "A": "基本表或视图",
        "B": "视图",
        "C": "基本表",
        "D": "数据字典"
      },
      "correct_answer": "A",
      "analysis": "视图可以基于一个或多个基本表创建，也可以基于其他视图创建（嵌套视图），视图本身不存储数据，仅存储查询定义。"
    },
    {
      "id": 72,
      "type": "单选题",
      "title": "视图是一个\"虚表\"，视图的构造基于( )。",
      "options": {
        "A": "基本表",
        "B": "基本表或视图",
        "C": "视图",
        "D": "数据字典"
      },
      "correct_answer": "B",
      "analysis": "视图的数据源可以是基本表，也可以是其他视图，是基于查询结果的虚表，不存储实际数据。"
    },
    {
      "id": 73,
      "type": "单选题",
      "title": "下列关于视图的描述，正确的是（ ）。",
      "options": {
        "A": "视图可以像表一样存储数据",
        "B": "视图的更新操作总是被允许",
        "C": "视图是基于基本表的查询结果",
        "D": "视图不能嵌套创建"
      },
      "correct_answer": "C",
      "analysis": "A错误：视图是虚表，不存储数据；B错误：复杂视图（如含聚合函数、DISTINCT）无法更新；D错误：视图可以嵌套创建。"
    },
    {
      "id": 74,
      "type": "单选题",
      "title": "当对视图进行 UPDATE、INSERT和DELETE操作时，为了保证被操作的元组满足视图定义中子查询语句的谓词条件，应在视图定义语句中使用可选择项（ ）。",
      "options": {
        "A": "With Revoke Option",
        "B": "With Check Option",
        "C": "With Role Option",
        "D": "With Grant Option"
      },
      "correct_answer": "B",
      "analysis": "WITH CHECK OPTION用于保证通过视图修改的数据仍满足视图的查询条件，防止修改后的数据无法通过视图查询到。"
    },
    {
      "id": 75,
      "type": "单选题",
      "title": "下列关于视图的说法，错误的是（ ）。",
      "options": {
        "A": "视图可以基于一个或多个基本表创建",
        "B": "对视图的更新最终会转换为对基本表的更新",
        "C": "视图是物理存储的数据集合",
        "D": "视图能简化用户的数据查询操作"
      },
      "correct_answer": "C",
      "analysis": "视图是虚表，仅存储查询定义，不物理存储数据，所有对视图的操作最终都会映射到基本表上。"
    },
    {
      "id": 76,
      "type": "单选题",
      "title": "索引的以下哪种使用策略是不恰当的（ ）。",
      "options": {
        "A": "在频繁作为查询条件的列上建立索引",
        "B": "在频繁更新的列上建立大量索引",
        "C": "在外键列上建立索引以优化连接查询",
        "D": "在区分度高的列上建立索引"
      },
      "correct_answer": "B",
      "analysis": "索引会提升查询效率，但降低更新（INSERT/UPDATE/DELETE）效率，频繁更新的列上建立大量索引会严重影响性能。"
    },
    {
      "id": 77,
      "type": "单选题",
      "title": "在MySQL中，为Score表的grade列创建降序索引，正确的是( )。",
      "options": {
        "A": "CREATE INDEX idx_grade ON Score(grade);",
        "B": "CREATE INDEX idx_grade ON Score(grade DESC);",
        "C": "CREATE DESC INDEX idx_grade ON Score(grade);",
        "D": "CREATE INDEX idx_grade ON Score(grade ASC);"
      },
      "correct_answer": "B",
      "analysis": "MySQL中创建降序索引的语法为CREATE INDEX 索引名 ON 表名(列名 DESC)；ASC是升序（默认），无需显式指定。"
    },
    {
      "id": 78,
      "type": "单选题",
      "title": "下列关于索引的说法中正确的是（）。",
      "options": {
        "A": "一个表可以建立多个聚簇索引",
        "B": "索引只能建立在一个字段上",
        "C": "索引可以加快表之间连接的速度",
        "D": "只能使用CREATE INDEX句创建索引"
      },
      "correct_answer": "C",
      "analysis": "A错误：一个表只能有一个聚簇索引；B错误：支持复合索引（多个字段）；D错误：主键/唯一约束会自动创建索引。"
    },
    {
      "id": 79,
      "type": "单选题",
      "title": "下列关于索引的描述，正确的是（ ）。",
      "options": {
        "A": "索引会降低数据更新效率",
        "B": "一个表只能有一个索引",
        "C": "索引存储实际业务数据",
        "D": "删除索引会影响主键约束"
      },
      "correct_answer": "A",
      "analysis": "索引需要随数据更新而维护，因此会降低INSERT/UPDATE/DELETE效率；一个表可创建多个索引；索引仅存储索引键和指针，不存储业务数据；删除普通索引不影响主键约束。"
    },
    {
      "id": 80,
      "type": "单选题",
      "title": "对于需要快速查找等值条件（如 WHERE id=10）的列，最适合创建的索引是（ ）。",
      "options": {
        "A": "B +树索引",
        "B": "哈希索引",
        "C": "位图索引",
        "D": "全文索引"
      },
      "correct_answer": "B",
      "analysis": "哈希索引适用于等值查询（=），查询效率为O(1)；B+树索引适用于范围查询；位图索引适用于低基数列；全文索引适用于文本检索。"
    },
{
      "id": 81,
      "type": "单选题",
      "title": "对于频繁进行范围查询（如BETWEEN, >, <）的列，最适合创建的索引是（ ）。",
      "options": {
        "A": "唯一索引",
        "B": "位图索引",
        "C": "B+树索引",
        "D": "哈希索引"
      },
      "correct_answer": "C",
      "analysis": "B+树索引的结构支持高效的范围查询（如>、<、BETWEEN），哈希索引仅支持等值查询，无法用于范围查询。"
    },
    {
      "id": 82,
      "type": "单选题",
      "title": "下列关于数据库索引的描述，正确的是（ ）。",
      "options": {
        "A": "索引会降低数据查询效率，但能提升插入、更新操作的性能",
        "B": "一个表只能创建一个索引，且索引必须基于主键列",
        "C": "索引的本质是一种优化数据查询的数据结构，不存储实际业务数据",
        "D": "删除索引会导致对应的基本表数据丢失"
      },
      "correct_answer": "C",
      "analysis": "A错误：索引提升查询效率，降低更新效率；B错误：一个表可创建多个索引，索引可基于任意列；D错误：删除索引仅删除索引结构，不影响表数据。"
    },
    {
      "id": 83,
      "type": "单选题",
      "title": "下列不属于事务 ACID 特性的是（ ）。",
      "options": {
        "A": "原子性",
        "B": "并发性",
        "C": "一致性",
        "D": "隔离性"
      },
      "correct_answer": "B",
      "analysis": "事务的ACID特性包括：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），并发性不属于ACID特性。"
    },
    {
      "id": 84,
      "type": "单选题",
      "title": "下列关于事务隔离性的描述，正确的是（ ）。",
      "options": {
        "A": "事务一旦提交，对数据库的修改是永久的",
        "B": "事务中所有操作要么全部执行，要么全部不执行",
        "C": "多个事务并发执行时，一个事务的执行不能被其他事务干扰",
        "D": "事务执行前后，数据库的完整性约束保持不变"
      },
      "correct_answer": "C",
      "analysis": "A是持久性，B是原子性，C是隔离性，D是一致性。"
    },
    {
      "id": 85,
      "type": "单选题",
      "title": "事务的隔离性是指（ ）。",
      "options": {
        "A": "事务提交后结果永久",
        "B": "事务内部操作对外不可见",
        "C": "事务全部执行或全部不执行",
        "D": "事务之间互不干扰"
      },
      "correct_answer": "D",
      "analysis": "隔离性保证多个并发事务之间相互独立，互不干扰，每个事务都感觉不到其他事务的存在。"
    },
    {
      "id": 86,
      "type": "单选题",
      "title": "数据库恢复过程中，事务日志主要用于实现哪种恢复操作（ ）。",
      "options": {
        "A": "数据压缩",
        "B": "数据加密",
        "C": "回滚和重做",
        "D": "数据归档"
      },
      "correct_answer": "C",
      "analysis": "事务日志记录了所有对数据库的修改操作，故障恢复时可通过日志重做已提交的事务，回滚未提交的事务。"
    },
    {
      "id": 87,
      "type": "单选题",
      "title": "下列关于数据库事务ACID 特性的描述中，错误的是（ ）。",
      "options": {
        "A": "原子性指事务中的操作要么全部执行成功，要么全部回滚，不存在部分执行的情况",
        "B": "一致性指事务执行前后，数据库的完整性约束始终保持有效",
        "C": "隔离性指多个并发执行的事务之间相互独立，一个事务的执行不会被其他事务干扰，且所有事务看起来都是串行执行的",
        "D": "持久性指事务一旦提交，其对数据库的修改就会永久保存，即使发生数据库崩溃或系统故障也不会丢失"
      },
      "correct_answer": "C",
      "analysis": "隔离性不要求所有事务串行执行，而是通过隔离级别控制并发事务的可见性，不同隔离级别下事务的可见性不同。"
    },
    {
      "id": 88,
      "type": "单选题",
      "title": "下面选项中，关于MySQL中开启事务的SQL语句，正确的是（ ）。",
      "options": {
        "A": " BEGIN TRANSACTION;",
        "B": " START TRANSACTION;",
        "C": " END TRANSACTION;",
        "D": " STOP TRANSACTION;"
      },
      "correct_answer": "B",
      "analysis": "MySQL中开启事务的标准语句是START TRANSACTION；BEGIN TRANSACTION是T-SQL（SQL Server）语法；END/STOP TRANSACTION不是有效语句。"
    },
    {
      "id": 89,
      "type": "单选题",
      "title": "事务日志的用途是（ ）。",
      "options": {
        "A": "事务处理",
        "B": "数据恢复",
        "C": "完整性约束",
        "D": "安全性控制"
      },
      "correct_answer": "B",
      "analysis": "事务日志的核心作用是数据恢复，包括崩溃恢复、时点恢复等，保证事务的持久性和一致性。"
    },
    {
      "id": 90,
      "type": "单选题",
      "title": "DBS运行的最小逻辑单位是（）。",
      "options": {
        "A": "数据",
        "B": "事务",
        "C": "记录",
        "D": "函数"
      },
      "correct_answer": "B",
      "analysis": "事务是数据库系统运行的最小逻辑单位，所有数据库操作都以事务为单位执行，保证ACID特性。"
    },
 {
      "id": 91,
      "type": "单选题",
      "title": "关于MySQL中提交事务并将修改永久保存到数据库的SQL语句是（ ）。",
      "options": {
        "A": "ROLLBACK;",
        "B": "COMMIT;",
        "C": "SAVEPOINT;",
        "D": "RELEASE SAVEPOINT;"
      },
      "correct_answer": "B",
      "analysis": "COMMIT用于提交事务，将事务中的修改永久保存；ROLLBACK用于回滚事务；SAVEPOINT用于设置保存点；RELEASE SAVEPOINT用于释放保存点。"
    },
    {
      "id": 92,
      "type": "单选题",
      "title": "关于数据库事务的持久性特性，以下描述正确的是（ ）。",
      "options": {
        "A": "事务执行过程中的中间状态对其他事务不可见",
        "B": "事务提交后，其对数据库的修改是永久性的",
        "C": "事务中的所有操作要么全部执行，要么全部不执行",
        "D": "并发执行的事务互不干扰"
      },
      "correct_answer": "B",
      "analysis": "持久性（Durability）保证事务提交后，即使发生系统故障，修改也不会丢失；A是隔离性，C是原子性，D是隔离性。"
    },
    {
      "id": 93,
      "type": "单选题",
      "title": "MySQL中，用于回滚到保存点的语句是（ ）。",
      "options": {
        "A": "ROLLBACK TO SAVEPOINT",
        "B": "ROLLBACK",
        "C": "RETURN TO SAVEPOINT",
        "D": "RETURN"
      },
      "correct_answer": "A",
      "analysis": "ROLLBACK TO SAVEPOINT 保存点名 用于回滚到指定保存点；ROLLBACK会回滚整个事务；RETURN不是事务相关语句。"
    },
    {
      "id": 94,
      "type": "单选题",
      "title": "下列关于事务ACID特性的描述，错误的是（ ）。",
      "options": {
        "A": "原子性保证操作不可分割",
        "B": "一致性保证数据状态合法",
        "C": "隔离性允许事务相互干扰",
        "D": "持久性保证结果永久保存"
      },
      "correct_answer": "C",
      "analysis": "隔离性的核心是防止事务之间相互干扰，保证并发事务的独立性，而非允许干扰。"
    },
    {
      "id": 95,
      "type": "单选题",
      "title": "MySQL中用于设置自动提交模式关闭的命令是（ ）。",
      "options": {
        "A": "SET autocommit=0;",
        "B": "SET autocommit=TRUE;",
        "C": "START TRANSACTION;",
        "D": "COMMIT;"
      },
      "correct_answer": "A",
      "analysis": "MySQL默认自动提交（autocommit=1/TRUE），设置autocommit=0/FALSE可关闭自动提交，需手动COMMIT/ROLLBACK。"
    },
    {
      "id": 96,
      "type": "单选题",
      "title": "在MySQL存储过程中，声明局部变量的正确格式是（ ）。",
      "options": {
        "A": "DECLARE @name VARCHAR (20);",
        "B": "SET @name VARCHAR (20);",
        "C": "DECLARE name VARCHAR (20);",
        "D": "CREATE @name VARCHAR (20);"
      },
      "correct_answer": "C",
      "analysis": "MySQL存储过程中声明局部变量的语法为DECLARE 变量名 数据类型；@name是用户变量，不是局部变量。"
    },
    {
      "id": 97,
      "type": "单选题",
      "title": "局部变量的声明语句是（ ）。",
      "options": {
        "A": "DECLARE",
        "B": "SET",
        "C": "SELECT",
        "D": "PRINT"
      },
      "correct_answer": "A",
      "analysis": "DECLARE用于声明局部变量；SET/SELECT用于给变量赋值；PRINT用于输出（T-SQL）。"
    },
    {
      "id": 98,
      "type": "单选题",
      "title": "关于存储过程和函数的区别，说法正确的是（ ）。",
      "options": {
        "A": "存储过程不能返回值，函数可以返回值",
        "B": "存储过程可以有输出参数，函数只能有输入参数",
        "C": "存储过程可以包含事务控制语句，函数不能",
        "D": "存储过程不能被嵌套调用，函数可以"
      },
      "correct_answer": "C",
      "analysis": "A错误：存储过程可通过输出参数返回值；B错误：函数支持输出参数；D错误：存储过程可嵌套调用；C正确：函数中不能使用COMMIT/ROLLBACK等事务控制语句。"
    },
    {
      "id": 99,
      "type": "单选题",
      "title": "以下关于存储过程和触发器的说法，错误的是（ ）。",
      "options": {
        "A": "存储过程需要显式调用才能执行，而触发器是由特定事件自动触发的",
        "B": "存储过程可以返回多个结果集，而触发器不能有返回值",
        "C": "触发器可以在同一个表上创建多个，但触发时机（BEFORE/AFTER）相同的事件只能有一个触发器",
        "D": "存储过程和触发器都可以包含事务控制语句（如 COMMIT、ROLLBACK）"
      },
      "correct_answer": "D",
      "analysis": "触发器是事务的一部分，不能包含独立的COMMIT/ROLLBACK语句，否则会破坏原事务的原子性。"
    },
    {
      "id": 100,
      "type": "单选题",
      "title": "触发程序中的（ ）语句不能产生结果集。",
      "options": {
        "A": "INSERT",
        "B": "SELECT",
        "C": "UPDATE",
        "D": "DELETE"
      },
      "correct_answer": "B",
      "analysis": "触发器中不能执行返回结果集的SELECT语句（如SELECT * FROM 表），只能执行无结果集的SELECT（如SELECT ... INTO）。"
    },
{
      "id": 101,
      "type": "单选题",
      "title": "MySQL触发器中，引用UPDATE操作前记录的关键字是（ ）。",
      "options": {
        "A": "NEW",
        "B": "OLD",
        "C": "CURRENT",
        "D": "PAST"
      },
      "correct_answer": "B",
      "analysis": "MySQL触发器中，OLD引用更新/删除前的记录，NEW引用插入/更新后的记录。"
    },
    {
      "id": 102,
      "type": "单选题",
      "title": "MySQL数据库操作用于备份数据库的命令是（ ）。",
      "options": {
        "A": "MYSQLDUMP",
        "B": "EXPORT DATABASE",
        "C": "BACKUP DATABASE",
        "D": "BACKUP TABLE"
      },
      "correct_answer": "A",
      "analysis": "mysqldump是MySQL官方的备份工具，用于导出数据库结构和数据；EXPORT/BACKUP DATABASE是SQL Server语法。"
    },
    {
      "id": 103,
      "type": "单选题",
      "title": "在MySQL中，用于收回用户对表的DELETE权限的命令是（ ）。",
      "options": {
        "A": "REVOKE DELETE ON … FROM …",
        "B": "TAKE BACK DELETE ON … FROM …",
        "C": "REMOVE DELETE ON … FROM …",
        "D": "CANCEL DELETE ON … FROM …"
      },
      "correct_answer": "A",
      "analysis": "SQL标准中，授予权限用GRANT，收回权限用REVOKE，其他选项均非有效命令。"
    },
    {
      "id": 104,
      "type": "单选题",
      "title": "用于记录数据库中所有更新操作，为故障恢复提供依据的是（ ）。",
      "options": {
        "A": "数据字典",
        "B": "日志文件",
        "C": "索引文件",
        "D": "备份文件"
      },
      "correct_answer": "B",
      "analysis": "日志文件（如重做日志、二进制日志）记录所有更新操作，是故障恢复的核心依据；备份文件用于基础恢复，日志用于增量恢复。"
    },
    {
      "id": 105,
      "type": "单选题",
      "title": "在MySQL中，用于授予用户对表执行SELECT权限的命令是（ ）。",
      "options": {
        "A": "GRANT SELECT ON … TO …",
        "B": "ALLOW SELECT ON … TO …",
        "C": "PERMIT SELECT ON … TO …",
        "D": "AUTHORIZE SELECT ON … TO …"
      },
      "correct_answer": "A",
      "analysis": "GRANT是授予权限的标准SQL命令，语法为GRANT 权限 ON 表名 TO 用户名。"
    },
    {
      "id": 106,
      "type": "单选题",
      "title": "用于实现数据库故障恢复的核心技术是（ ）。",
      "options": {
        "A": "视图",
        "B": "索引",
        "C": "日志文件",
        "D": "存储过程"
      },
      "correct_answer": "C",
      "analysis": "日志文件记录了所有数据库修改操作，故障恢复时通过重做日志（REDO）和回滚日志（UNDO）恢复数据，是故障恢复的核心。"
    },
    {
      "id": 107,
      "type": "单选题",
      "title": "数据库恢复的基本原则是（ ）。",
      "options": {
        "A": "有备份即可恢复",
        "B": "利用备份和事务日志恢复",
        "C": "仅恢复数据不恢复结构",
        "D": "优先恢复索引"
      },
      "correct_answer": "B",
      "analysis": "数据库恢复需要结合全量备份（基础）和事务日志（增量），才能恢复到故障前的最新状态；仅备份只能恢复到备份时点，无法恢复后续数据。"
    },
    {
      "id": 108,
      "type": "单选题",
      "title": "在数据库中，以下哪种权限允许用户修改现有表的结构（ ）。",
      "options": {
        "A": "ALTER",
        "B": "MODIFY",
        "C": "UPDATE",
        "D": "CREATE"
      },
      "correct_answer": "A",
      "analysis": "ALTER权限允许用户执行ALTER TABLE语句修改表结构；UPDATE权限仅允许修改表数据；CREATE权限允许创建表/数据库。"
    },
    {
      "id": 109,
      "type": "单选题",
      "title": "在执行数据库差异备份之前，需要事先完成的备份是（）。",
      "options": {
        "A": "数据库完整备份",
        "B": "数据库差异备份",
        "C": "事务日志备份",
        "D": "文件和文件组备份"
      },
      "correct_answer": "A",
      "analysis": "差异备份是基于最近一次完整备份的增量备份，必须先完成完整备份才能执行差异备份。"
    },
    {
      "id": 110,
      "type": "单选题",
      "title": "数据库的并发控制主要解决的问题是（ ）。",
      "options": {
        "A": "数据丢失",
        "B": "数据重复",
        "C": "数据不一致",
        "D": "数据加密"
      },
      "correct_answer": "C",
      "analysis": "并发控制通过锁、隔离级别等机制，解决多个事务并发执行时可能出现的脏读、不可重复读、幻读等数据不一致问题。"
    },
    {
      "id": 111,
      "type": "单选题",
      "title": "下面有关数据库还原的说法中，错误的是（）",
      "options": {
        "A": "还原数据库是通过备份好的数据文件进行还原",
        "B": "还原是指还原数据库中的数据，而库是不能被还原的",
        "C": "使用mysql命令可以还原数据库中的数据",
        "D": "数据库中的库可以被还原的"
      },
      "correct_answer": "B",
      "analysis": "数据库还原既可以还原数据，也可以还原库结构（如通过mysqldump备份的完整库，还原时会重建库和表结构），B的描述错误。"
    }
	
  ]
}
